#include <SoftwareSerial.h>

// OneWire - Version: 2.3.7
#include <OneWire.h>

// DallasTemperature - Version: 3.9.0
#include <DallasTemperature.h>

/* 
  Sketch generated by the Arduino IoT Cloud Thing "MHMS"
  https://create.arduino.cc/cloud/things/b928bda8-b5ac-47e0-95cd-4021c625627a 

  Arduino IoT Cloud Variables:
  	CloudElectricPotential dC_Motor;
  	float vibration;
  	CloudTemperatureSensor temp;
  	int motor_Direction;
  	bool sound;
*/

#include "thingProperties.h"

#define ALARM_PIN 12         // LED
#define SOUND_PIN 13         // Sound Sensor
#define ONE_WIRE_BUS0 4      // Temperature Sensor
#define PIEZO_PIN A0         // Vibration Sensor
#define ENA 14               // DC Motor PWM
#define IN1 0                // DC Motor Direction Input Pin 1
#define IN2 2                // DC Motor Direction Input Pin 2
#define Lubricating_Relay 5  // Relay For Turning On Lubricating System

int monitor_TimeOn = 60;                // Time Allowed to Be On During Monitoring Mode
boolean machineOn = false;
bool monitor = false;
boolean lubrication = false;
// Timer: Auxiliary variables
unsigned long now = millis();
unsigned long lastTrigger = 0;
unsigned long last = 0;
boolean startTimer = false;
unsigned long StartTime = 0;
unsigned long StopTime = 0;
unsigned long Time_ON = 0;
unsigned long LubricationPeriod = 0; // Time Between Lubrication Times
unsigned long LubricationDone = 0;   // Time of Each Lubrication
String str, strs;

float PWM = 0;

OneWire oneWire(ONE_WIRE_BUS0); 
DallasTemperature tempSensors(&oneWire);

const int sampleWindow = 50;
unsigned int sample;

void setup() {
  Serial.begin(9600);
  Serial1.begin(9600);

  tempSensors.begin();
  pinMode(SOUND_PIN, INPUT);
  pinMode(ALARM_PIN, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT); 
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);

  initProperties();

  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  delay(2000);
}

void loop() {
  ArduinoCloud.update();
  
  now = millis();

  int in1 = digitalRead(IN1);
  int in2 = digitalRead(IN2);
  
  if((in1 ^ in2) & !(machineOn)){
    machineOn = true;
    StartTime = now;
  }
  else if ((in1 ^ in2) & (machineOn)) {
    StopTime = millis();
    //time_On = (StopTime - StartTime)/60;
  }
  else if (!(in1 ^ in2) & (machineOn)) {
    machineOn = false;
    StopTime = millis();
    //time_On = (StopTime - StartTime)/60;
  }
  Time_ON = (StopTime-StartTime)/1000;
  //Serial.println(Time_ON);
  //Serial.println(lastTrigger/1000);
  //Serial.println(last/1000);
  
  tempSensors.requestTemperatures();                 //TEMPERATURE
  temp = tempSensors.getTempCByIndex(0);
  Serial.print("T: ");
  Serial.print(temp);
  Serial.print("C ");
  
  vibration = analogRead(PIEZO_PIN)/ 256.0 * 10.0;  //VIBRATION
  Serial.print("V: ");
  Serial.print(vibration);
  Serial.print(" ");
  
  sound = !digitalRead(SOUND_PIN);                    //SOUND
  if (sound){
    strs = "Max t: N/A";
  }
  else {
    strs = "Max t: 8h/d";
  }
  Serial.println(strs);
  
  if((temp>80) & (vibration>4.5)){            // Case 1
    //Serial.println("Danger!");
    monitor = false;
    digitalWrite(ALARM_PIN, HIGH);
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
  }
  else if((temp>55) & (vibration>3.5)){       // Case 2
    //Serial.println("Schedule for Repair.");
    digitalWrite(ALARM_PIN, LOW);
    LubricationPeriod = 60;
    LubricationDone = 10;
    monitor = true;
  }
  else if ((temp <= 0) | (vibration < 0)){   // Case 3
    digitalWrite(ALARM_PIN, HIGH);
    LubricationPeriod = 100;
    LubricationDone = 5;
    monitor = true;
    if(temp <= 0){
      Serial.println("Temperature Sensor NOT Working!");
    }
    if(vibration <= 0){
      Serial.println("Vibration Sensor NOT Working!");
    }
  }
  else {
    //Serial.println("Normal Operation.");      // Case 4
    digitalWrite(ALARM_PIN, LOW);
    LubricationPeriod = 100;
    LubricationDone = 5;
    monitor = false;
  }

  if((monitor) && (!startTimer) && machineOn){
    lastTrigger = millis();
    startTimer = true;
  }
  // Turn off the Machine after the allowed operational time defined in the monitor_TimeOn variable
  else if(startTimer && ((now - lastTrigger) >= (monitor_TimeOn*1000)) && machineOn) {
  //else if(startTimer && (Time_ON >= (monitor_TimeOn*1000)) && machineOn) {
    Serial.println("Machine Off");
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    digitalWrite(ENA, LOW);
    startTimer = false;
  }
  
  if(((now - last) > (LubricationPeriod*100)) && machineOn && !lubrication) {
    //Serial.println("Lubricating...");
    digitalWrite(Lubricating_Relay, HIGH);
    lubrication = true;
    last = now;//Time_ON; //millis();
  }
  else if(((now - last)>=((LubricationPeriod*100)*2)) && !machineOn && !lubrication) {
    //Serial.println("Lubricating...");
    digitalWrite(Lubricating_Relay, HIGH);
    lubrication = true;
    last = now;
  }
  if(((now - last) >= (LubricationDone*1000)) && lubrication){
    //Serial.println("DONE Lubricating.");
    digitalWrite(Lubricating_Relay, LOW);
    lubrication = false;
    last = millis();
  }
  
  float peakToPeak = 0;                               // peak-to-peak level
 
  unsigned int signalMax = 0;                         //minimum value
  unsigned int signalMin = 1024;                      //maximum value
 
  while (millis() - startMillis < sampleWindow)       // collect data for 50 mS
  {
    sample = analogRead(SOUND_PIN);                   //get reading from microphone
    if (sample < 1024)                                // toss out spurious readings
    {
      if (sample > signalMax)
      {
        signalMax = sample;                           // save just the max levels
      }
      else if (sample < signalMin)
      {
        signalMin = sample;                           // save just the min levels
      }
    }
   }
  peakToPeak = signalMax - signalMin;                 // max - min = peak-peak amplitude
  sound = map(peakToPeak,20,900,49.5,90);             //calibrate for deciBels
  
  Serial.print("Sound is: ");                         //Sound
  Serial.print(sound);
  Serial.println(" dB");*/
  
  /* 
  if (db <= 70)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: N/A");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: N/A.");
  }
  else if (db > 70 && db<=85)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: 8h");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: 8 hours/day.");
  }
  else if (85<db<=91)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: 6h");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: 6 hours/day.");
  }
  else if (91<db<=95)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: 4h");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: 4 hours/day.");
  }
  else if (95<db<=97)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: 3h");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: 3 hours/day.");
  }
  else if (db>97)
  {
    lcd.setCursor(0, 1);
    lcd.print("Max. Time: 2h");
    Serial.print("Sound is: ");
    Serial.print(sound);
    Serial.println("dB");
    Serial.println("Maximum Exposure Time: 2 hours/day.");
  }
  else {}
  */
  delay(1000);
}

void onDCMotorChange()  {
  // Add your code here to act upon DCMotor change
  PWM = dC_Motor*1023/100;
  analogWrite(ENA, PWM);
}

void onMotorDirectionChange()  {
  if(motor_Direction==0){
    digitalWrite(IN1,LOW);
    digitalWrite(IN2,LOW);
    analogWrite(ENA, 0);
  }
  else if(motor_Direction==1){
    digitalWrite(IN1,LOW);
    digitalWrite(IN2,HIGH);
    analogWrite(ENA, PWM);
  }
  else if(motor_Direction==2){
    digitalWrite(IN1,HIGH);
    digitalWrite(IN2,LOW);
    analogWrite(ENA, PWM);
  }
  else{
    Serial.println("ERROR!");
  }
}


